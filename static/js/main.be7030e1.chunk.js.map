{"version":3,"sources":["../../src/components/AudioRenderer.tsx","../../src/components/ControlButton.tsx","../../src/useParticipant.ts","../../src/components/ControlsView.tsx","../../src/components/VideoRenderer.tsx","../../src/components/ParticipantView.tsx","../../src/components/desktop/DesktopStage.tsx","../../src/components/StageView.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/LiveKitRoom.tsx","../../src/useRoom.ts","PreJoinPage.tsx","RoomPage.tsx","App.tsx","index.tsx"],"names":["AudioRenderer","track","isLocal","audioEl","useRef","useEffect","el","ControlButton","label","disabled","onClick","className","styles","useParticipant","participant","useState","isMuted","setMuted","isSpeaking","setSpeaking","metadata","setMetadata","publications","setPublications","subscribedTracks","setSubscribedTracks","onPublicationsChanged","useCallback","Array","pub","unpublishTrack","Error","onMuted","Track","onUnmuted","onMetadataChanged","onIsSpeakingChanged","ParticipantEvent","ControlsView","room","audioPub","val","videoPub","muteButton","createLocalAudioTrack","audioTrack","videoButton","createLocalVideoTrack","videoTrack","VideoRenderer","width","height","ref","isFrontFacing","style","transform","ParticipantView","aspect","displayName","showOverlay","onMouseOver","onMouseOut","containerStyles","DesktopStage","roomState","participantRenderer","isConnecting","error","participants","setShowOverlay","React","mainParticipant","otherParticipants","numToAdd","i","ParticipantRenderer","key","identity","StageView","stageProps","useMediaQuery","query","Symbol","iterator","asyncIterator","LiveKitRoom","props","setRoom","setIsConnecting","setError","setParticipants","connect","body","recover","result","e","then","url","token","disconnect","newRoom","onParticipantsChanged","remotes","localParticipant","a","b","aLast","aVideo","localIdx","sortParticipants","RoomEvent","setTimeout","window","useRoom","PreJoinPage","setUrl","setToken","simulcast","setSimulcast","videoEnabled","setVideoEnabled","audioEnabled","setAudioEnabled","connectDisabled","setConnectDisabled","videoRef","setVideoTrack","history","useHistory","current","videoEl","attach","detach","stop","type","name","value","onChange","target","checked","undefined","params","push","pathname","search","URLSearchParams","toString","RoomPage","useLocation","get","onConnected","publishTrack","options","App","path","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.be7030e1.chunk.js","sourcesContent":["import { Track } from 'livekit-client'\nimport { useEffect, useRef } from 'react'\n\nexport interface AudioTrackProps {\n  track: Track\n  isLocal: boolean\n}\n\nexport const AudioRenderer = ({ track, isLocal }: AudioTrackProps) => {\n  const audioEl = useRef<HTMLAudioElement>()\n\n  useEffect(() => {\n    if (isLocal) {\n      // don't play own audio\n      return\n    }\n    audioEl.current = track.attach()\n    if (track.sid) {\n      audioEl.current.setAttribute('data-audio-track-id', track.sid)\n    }\n    return () => track.detach().forEach((el) => el.remove())\n  }, [track, isLocal])\n\n  // TODO: allow set sink id\n  return null\n}\n","import React from \"react\";\nimport styles from \"./styles.module.css\";\n\ninterface ButtonProps {\n  label: string;\n  disabled?: boolean;\n  onClick?: () => void;\n}\n\nexport const ControlButton = ({ label, disabled, onClick }: ButtonProps) => {\n  return (\n    <button disabled={disabled} className={styles.button} onClick={onClick}>\n      {label}\n    </button>\n  );\n};\n","import {\n  LocalParticipant,\n  LocalTrack,\n  Participant,\n  ParticipantEvent,\n  Track,\n  TrackPublication,\n} from \"livekit-client\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nexport interface ParticipantState {\n  isSpeaking: boolean;\n  isLocal: boolean;\n  isMuted: boolean;\n  metadata?: string;\n  publications: TrackPublication[];\n  subscribedTracks: TrackPublication[];\n  unpublishTrack: (track: LocalTrack) => void;\n}\n\nexport function useParticipant(participant: Participant): ParticipantState {\n  const [isMuted, setMuted] = useState(false);\n  const [isSpeaking, setSpeaking] = useState(false);\n  const [metadata, setMetadata] = useState<string>();\n  const [publications, setPublications] = useState<TrackPublication[]>([]);\n  const [subscribedTracks, setSubscribedTracks] = useState<TrackPublication[]>(\n    []\n  );\n\n  const onPublicationsChanged = useCallback(() => {\n    setPublications(Array.from(participant.tracks.values()));\n    setSubscribedTracks(\n      Array.from(participant.tracks.values()).filter((pub) => {\n        return pub.track !== undefined;\n      })\n    );\n  }, []);\n  const unpublishTrack = useCallback(async (track: LocalTrack) => {\n    if (!(participant instanceof LocalParticipant)) {\n      throw new Error(\"could not unpublish, not a local participant\");\n    }\n    (participant as LocalParticipant).unpublishTrack(track);\n    onPublicationsChanged();\n  }, []);\n\n  useEffect(() => {\n    const onMuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setMuted(true);\n      }\n    };\n    const onUnmuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setMuted(false);\n      }\n    };\n    const onMetadataChanged = () => {\n      if (participant.metadata) {\n        setMetadata(participant.metadata);\n      }\n    };\n    const onIsSpeakingChanged = () => {\n      setSpeaking(participant.isSpeaking);\n    };\n\n    // register listeners\n    participant.on(ParticipantEvent.TrackMuted, onMuted);\n    participant.on(ParticipantEvent.TrackUnmuted, onUnmuted);\n    participant.on(ParticipantEvent.MetadataChanged, onMetadataChanged);\n    participant.on(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged);\n    participant.on(ParticipantEvent.TrackPublished, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackUnpublished, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackSubscribed, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged);\n\n    // set initial state\n    onMetadataChanged();\n    onIsSpeakingChanged();\n    onPublicationsChanged();\n    participant.audioTracks.forEach((pub) => {\n      setMuted(pub.isMuted);\n    });\n\n    return () => {\n      // cleanup\n      participant.off(ParticipantEvent.TrackMuted, onMuted);\n      participant.off(ParticipantEvent.TrackUnmuted, onUnmuted);\n      participant.off(ParticipantEvent.MetadataChanged, onMetadataChanged);\n      participant.off(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged);\n      participant.off(ParticipantEvent.TrackPublished, onPublicationsChanged);\n      participant.off(ParticipantEvent.TrackUnpublished, onPublicationsChanged);\n      participant.off(ParticipantEvent.TrackSubscribed, onPublicationsChanged);\n      participant.off(\n        ParticipantEvent.TrackUnsubscribed,\n        onPublicationsChanged\n      );\n    };\n  }, []);\n\n  return {\n    isLocal: participant instanceof LocalParticipant,\n    isSpeaking,\n    isMuted,\n    publications,\n    subscribedTracks,\n    metadata,\n    unpublishTrack,\n  };\n}\n","import {\n  createLocalAudioTrack,\n  createLocalVideoTrack,\n  LocalTrackPublication,\n  LocalVideoTrack,\n  Room,\n  Track,\n} from \"livekit-client\";\nimport React, { ReactElement } from \"react\";\nimport { useParticipant } from \"../useParticipant\";\nimport { ControlButton } from \"./ControlButton\";\nimport styles from \"./styles.module.css\";\nexport interface ControlsProps {\n  room: Room;\n}\n\nexport const ControlsView = ({ room }: ControlsProps) => {\n  const { publications, isMuted, unpublishTrack } = useParticipant(\n    room.localParticipant\n  );\n\n  const audioPub = publications.find((val) => val.kind === Track.Kind.Audio);\n  const videoPub = publications.find((val) => {\n    return val.kind === Track.Kind.Video && val.trackName !== \"screen\";\n  });\n\n  let muteButton: ReactElement;\n  if (!audioPub || isMuted) {\n    muteButton = (\n      <ControlButton\n        label=\"Unmute\"\n        onClick={async () => {\n          if (audioPub) {\n            (audioPub as LocalTrackPublication).unmute();\n          } else {\n            // track not published\n            const audioTrack = await createLocalAudioTrack();\n            room.localParticipant.publishTrack(audioTrack);\n          }\n        }}\n      />\n    );\n  } else {\n    muteButton = (\n      <ControlButton\n        label=\"Mute\"\n        onClick={() => (audioPub as LocalTrackPublication).mute()}\n      />\n    );\n  }\n\n  let videoButton: ReactElement;\n  if (videoPub?.track) {\n    videoButton = (\n      <ControlButton\n        label=\"Stop video\"\n        onClick={() => unpublishTrack(videoPub.track as LocalVideoTrack)}\n      />\n    );\n  } else {\n    videoButton = (\n      <ControlButton\n        label=\"Start video\"\n        onClick={async () => {\n          const videoTrack = await createLocalVideoTrack();\n          await room.localParticipant.publishTrack(videoTrack);\n        }}\n      />\n    );\n  }\n\n  return (\n    <div className={styles.controlsWrapper}>\n      {muteButton}\n      {videoButton}\n      <ControlButton label=\"Leave\" onClick={() => room.disconnect()} />\n    </div>\n  );\n};\n","import { Property } from \"csstype\";\nimport { Track } from \"livekit-client\";\nimport React, { useEffect, useRef } from \"react\";\nimport styles from \"./styles.module.css\";\n\nexport interface VideoRendererProps {\n  track: Track;\n  isLocal: boolean;\n  className?: string;\n  width?: Property.Width;\n  height?: Property.Height;\n}\n\nexport const VideoRenderer = ({\n  track,\n  isLocal,\n  className,\n  width,\n  height,\n}: VideoRendererProps) => {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) {\n      return;\n    }\n    el.muted = true;\n    track.attach(el);\n    return () => {\n      track.detach(el);\n    };\n  }, [track]);\n\n  const isFrontFacing =\n    track.mediaStreamTrack?.getSettings().facingMode !== \"environment\";\n  const style = {\n    transform: isLocal && isFrontFacing ? \"rotateY(180deg)\" : \"\",\n    width: width,\n    height: height,\n  };\n\n  // TODO: could use react native RCTVideoView\n\n  return (\n    <video ref={ref} className={className ?? styles.video} style={style} />\n  );\n};\n","import { Property } from \"csstype\";\nimport { Participant, Track } from \"livekit-client\";\nimport React, { CSSProperties } from \"react\";\nimport { useParticipant } from \"../useParticipant\";\nimport { AudioRenderer } from \"./AudioRenderer\";\nimport styles from \"./styles.module.css\";\nimport { VideoRenderer } from \"./VideoRenderer\";\n\nexport interface ParticipantProps {\n  participant: Participant;\n  displayName?: string;\n  width?: Property.Width;\n  height?: Property.Height;\n  aspect?: string;\n  showOverlay?: boolean;\n  onMouseOver?: () => void;\n  onMouseOut?: () => void;\n}\n\nexport const ParticipantView = ({\n  participant,\n  width,\n  height,\n  aspect,\n  displayName,\n  showOverlay,\n  onMouseOver,\n  onMouseOut,\n}: ParticipantProps) => {\n  const { isLocal, subscribedTracks } = useParticipant(participant);\n\n  let audioTrack: Track | undefined;\n  let videoTrack: Track | undefined;\n\n  subscribedTracks.forEach((pub) => {\n    if (pub.kind === Track.Kind.Audio && !audioTrack) {\n      audioTrack = pub.track;\n    }\n    if (pub.kind === Track.Kind.Video && !videoTrack) {\n      videoTrack = pub.track;\n    }\n  });\n\n  const containerStyles: CSSProperties = {\n    width: width,\n    height: height,\n  };\n\n  if (!aspect) {\n    aspect = \"16 / 9\";\n  }\n  if (width && height === undefined) {\n    containerStyles.aspectRatio = aspect;\n  }\n\n  if (!displayName) {\n    displayName = participant.identity;\n    if (isLocal) {\n      displayName += \" (You)\";\n    }\n  }\n\n  return (\n    <div\n      className={styles.participant}\n      style={containerStyles}\n      onMouseOver={onMouseOver}\n      onMouseOut={onMouseOut}\n    >\n      {audioTrack && <AudioRenderer track={audioTrack} isLocal={isLocal} />}\n\n      {videoTrack && (\n        <VideoRenderer\n          track={videoTrack}\n          isLocal={isLocal}\n          width=\"100%\"\n          height=\"100%\"\n        />\n      )}\n\n      {showOverlay && (\n        <div className={styles.participantName}>{displayName}</div>\n      )}\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const DesktopStage = ({\n  roomState,\n  participantRenderer,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const mainParticipant = participants[0];\n  const otherParticipants = participants.slice(1);\n\n  // TEST CODE\n  const numToAdd = 8 - otherParticipants.length;\n  for (let i = 0; i < numToAdd; i++) {\n    otherParticipants.push(mainParticipant);\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={styles.stage}>\n        <div className={styles.stageCenter}>\n          <ParticipantRenderer\n            participant={mainParticipant}\n            height=\"100%\"\n            showOverlay={showOverlay}\n            onMouseOver={() => setShowOverlay(true)}\n            onMouseOut={() => setShowOverlay(false)}\n          />\n        </div>\n        <div className={styles.sidebar}>\n          {otherParticipants.map((participant) => {\n            return (\n              <ParticipantRenderer\n                key={participant.identity}\n                participant={participant}\n                width=\"100%\"\n                showOverlay={showOverlay}\n                onMouseOver={() => setShowOverlay(true)}\n                onMouseOut={() => setShowOverlay(false)}\n              />\n            );\n          })}\n        </div>\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlsView room={room} />\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { useMediaQuery } from \"react-responsive\";\nimport { DesktopStage } from \"./desktop/DesktopStage\";\nimport { StageProps } from \"./StageProps\";\n\nexport const StageView = (stageProps: StageProps) => {\n  const isMobile = useMediaQuery({ query: \"(max-width: 800px)\" });\n  if (isMobile) {\n    return null;\n  }\n\n  return <DesktopStage {...stageProps} />;\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { ConnectOptions, Room } from \"livekit-client\";\nimport React, { useEffect } from \"react\";\nimport { ParticipantProps } from \"./components/ParticipantView\";\nimport { StageProps } from \"./components/StageProps\";\nimport { StageView } from \"./components/StageView\";\nimport { useRoom } from \"./useRoom\";\n\nexport interface RoomProps {\n  url: string;\n  token: string;\n  connectOptions?: ConnectOptions;\n  onConnected?: (room: Room) => void;\n  stageRenderer?: (renderProps: StageProps) => React.ReactElement | null;\n  participantRenderer?: (\n    renderProps: ParticipantProps\n  ) => React.ReactElement | null;\n}\n\nexport const LiveKitRoom = (props: RoomProps) => {\n  const roomState = useRoom();\n\n  useEffect(() => {\n    roomState\n      .connect(props.url, props.token, props.connectOptions)\n      .then((room) => {\n        if (room && props.onConnected) {\n          props.onConnected(room);\n        }\n      });\n  }, []);\n\n  const stageRenderer = props.stageRenderer ?? StageView;\n\n  return stageRenderer({ roomState });\n};\n","import {\n  connect,\n  ConnectOptions,\n  LocalParticipant,\n  Participant,\n  Room,\n  RoomEvent,\n} from \"livekit-client\";\nimport { useCallback, useState } from \"react\";\n\nexport interface RoomState {\n  connect: (\n    url: string,\n    token: string,\n    options?: ConnectOptions\n  ) => Promise<Room | undefined>;\n  isConnecting: boolean;\n  room?: Room;\n  participants: Participant[];\n  error?: Error;\n}\n\nexport function useRoom(): RoomState {\n  const [room, setRoom] = useState<Room>();\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [error, setError] = useState<Error>();\n  const [participants, setParticipants] = useState<Participant[]>([]);\n\n  const connectFn = useCallback(\n    async (url: string, token: string, options?: ConnectOptions) => {\n      setIsConnecting(true);\n      try {\n        const newRoom = await connect(url, token, options);\n        setRoom(newRoom);\n        const disconnect = () => newRoom.disconnect();\n        const onParticipantsChanged = () => {\n          const remotes = Array.from(newRoom.participants.values());\n          const participants: Participant[] = [newRoom.localParticipant];\n          participants.push(...remotes);\n          sortParticipants(participants, newRoom.localParticipant);\n          setParticipants(participants);\n        };\n\n        newRoom.once(RoomEvent.Disconnected, () => {\n          setTimeout(() => setRoom(undefined));\n          window.removeEventListener(\"beforeunload\", disconnect);\n\n          newRoom.off(RoomEvent.ParticipantConnected, onParticipantsChanged);\n          newRoom.off(RoomEvent.ParticipantDisconnected, onParticipantsChanged);\n          newRoom.off(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged);\n        });\n        newRoom.on(RoomEvent.ParticipantConnected, onParticipantsChanged);\n        newRoom.on(RoomEvent.ParticipantDisconnected, onParticipantsChanged);\n        newRoom.on(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged);\n\n        setIsConnecting(false);\n        onParticipantsChanged();\n\n        window.addEventListener(\"beforeunload\", disconnect);\n\n        return newRoom;\n      } catch (error) {\n        setIsConnecting(false);\n        setError(error);\n\n        return undefined;\n      }\n    },\n    []\n  );\n\n  return {\n    connect: connectFn,\n    isConnecting,\n    room,\n    error,\n    participants,\n  };\n}\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. dominant speaker (speaker with the loudest audio level)\n * 2. local participant\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(\n  participants: Participant[],\n  localParticipant?: LocalParticipant\n) {\n  participants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return b.audioLevel - a.audioLevel;\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      if (a.isSpeaking) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      const aLast = a.lastSpokeAt?.getTime() ?? 0;\n      const bLast = b.lastSpokeAt?.getTime() ?? 0;\n      return bLast - aLast;\n    }\n\n    // video on\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n  });\n\n  if (localParticipant) {\n    const localIdx = participants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      participants.splice(localIdx, 1);\n      if (participants.length > 0) {\n        participants.splice(1, 0, localParticipant);\n      } else {\n        participants.push(localParticipant);\n      }\n    }\n  }\n}\n","import { createLocalVideoTrack, LocalVideoTrack } from 'livekit-client'\nimport { ControlButton, VideoRenderer } from 'livekit-react'\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { useHistory } from 'react-router-dom'\n\nexport const PreJoinPage = () => {\n  // state to pass onto room\n  const [url, setUrl] = useState('ws://localhost:7880')\n  const [token, setToken] = useState<string>('')\n  const [simulcast, setSimulcast] = useState(false)\n  const [videoEnabled, setVideoEnabled] = useState(false)\n  const [audioEnabled, setAudioEnabled] = useState(false)\n  // disable connect button unless validated\n  const [connectDisabled, setConnectDisabled] = useState(true)\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [videoTrack, setVideoTrack] = useState<LocalVideoTrack>();\n  const history = useHistory()\n\n  useEffect(() => {\n    if (!videoRef.current || !videoTrack) {\n      return\n    }\n    const videoEl = videoRef.current;\n    videoTrack.attach(videoEl)\n    return () => {\n      videoTrack.detach(videoEl)\n      videoTrack.stop()\n    }\n  }, [videoTrack, videoRef])\n\n  useEffect(() => {\n    if (token && url) {\n      setConnectDisabled(false)\n    } else {\n      setConnectDisabled(true)\n    }\n  }, [token, url])\n\n  const toggleVideo = () => {\n    if (videoTrack) {\n      videoTrack.stop()\n      setVideoEnabled(false)\n      setVideoTrack(undefined)\n    } else {\n      createLocalVideoTrack().then((track) => {\n        setVideoEnabled(true)\n        setVideoTrack(track)\n      })\n    }\n  }\n\n  useEffect(() => {\n    // enable video by default\n    createLocalVideoTrack().then((track) => {\n      setVideoEnabled(true)\n      setVideoTrack(track)\n    })\n  }, [])\n\n  const toggleAudio = () => {\n    if (audioEnabled) {\n      setAudioEnabled(false)\n    } else {\n      setAudioEnabled(true)\n    }\n  }\n\n  const connectToRoom = () => {\n    const params: {[key: string]: string} = {\n      url,\n      token,\n      videoEnabled: videoEnabled ? '1' : '0',\n      audioEnabled: audioEnabled ? '1' : '0',\n      simulcast: simulcast ? '1' : '0',\n    }\n    history.push({\n      pathname: '/room',\n      search: \"?\" + new URLSearchParams(params).toString()\n    })\n  }\n\n  return (\n    <div className=\"prejoin\">\n      <main>\n        <h2>LiveKit Video</h2>\n        <hr/>\n        <div className=\"entrySection\">\n          <div>\n            <div className=\"label\">\n              LiveKit URL\n            </div>\n            <div>\n              <input type=\"text\" name=\"url\" value={url} onChange={e => setUrl(e.target.value)} />\n            </div>\n          </div>\n          <div>\n            <div className=\"label\">\n              Token\n            </div>\n            <div>\n              <input type=\"text\" name=\"token\" value={token} onChange={e => setToken(e.target.value)} />\n            </div>\n          </div>\n          <div>\n            <input type=\"checkbox\" name=\"simulcast\" checked={simulcast} onChange={e => setSimulcast(e.target.checked)}/>\n            <label>Simulcast</label>\n          </div>\n        </div>\n\n        <div className=\"videoSection\">\n          {videoTrack && <VideoRenderer track={videoTrack} isLocal={true} />}\n        </div>\n\n        <div className=\"controlSection\">\n          <div>\n            <ControlButton label={audioEnabled ? 'Mute' : 'Unmute'} onClick={toggleAudio}/>\n            <ControlButton label={videoTrack ? 'Disable Video' : 'Enable Video'} onClick={toggleVideo}/>\n          </div>\n          <div className=\"right\">\n            <ControlButton label=\"Connect\" disabled={connectDisabled} onClick={connectToRoom}/>\n          </div>\n        </div>\n      </main>\n    </div>\n  )\n}\n","import { createLocalAudioTrack, createLocalVideoTrack, Room, TrackPublishOptions } from 'livekit-client'\nimport { LiveKitRoom } from 'livekit-react'\nimport React from \"react\"\nimport { useLocation } from 'react-router-dom'\n\nexport const RoomPage = () => {\n  const query = new URLSearchParams(useLocation().search)\n  const url = query.get('url')\n  const token = query.get('token')\n\n  if (!url || !token) {\n    return (\n      <div>\n        url and token are required\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"roomContainer\">\n      <h2>LiveKit Video</h2>\n      <LiveKitRoom url={url} token={token} onConnected={room => onConnected(room, query)}/>\n    </div>\n  )\n}\n\nasync function onConnected(room: Room, query: URLSearchParams) {\n  if (query.get('audioEnabled') === '1') {\n    const audioTrack = await createLocalAudioTrack()\n    await room.localParticipant.publishTrack(audioTrack)\n  }\n  if (query.get('videoEnabled') === '1') {\n    const options: TrackPublishOptions = {\n      name: 'camera'\n    }\n    if (query.get('simulcast') === '1') {\n      options.simulcast = true\n    }\n    const videoTrack = await createLocalVideoTrack();\n    await room.localParticipant.publishTrack(videoTrack, options)\n  }\n}\n","import 'livekit-react/dist/index.css'\nimport React from 'react'\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom'\nimport { PreJoinPage } from './PreJoinPage'\nimport { RoomPage } from './RoomPage'\n\nconst App = () => {\n  return (\n    <div className=\"container\">\n      <Router>\n        <Switch>\n          <Route path=\"/room\">\n            <RoomPage/>\n          </Route>\n          <Route path=\"/\">\n            <PreJoinPage/>\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}